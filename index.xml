<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>E4</title>
    <link>/</link>
    <description>Recent content on E4</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Basic application setup</title>
      <link>/getting-started/go/1-basic-app/</link>
      <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/getting-started/go/1-basic-app/</guid>
      <description>Let&#39;s start by creating a basic Go client application. It will:
 Read a client identifier from command line flags Connect to a MQTT broker (we&#39;ll use the public mqtt.eclipse.org:1338) Subscribe to the MQTT topic /e4go/demo/messages and print any incoming messages to stdout Wait for user input on stdin, so that the user can type in a message and press enter. Messages will then be published on the peer MQTT topic /e4go/demo/messages.</description>
    </item>
    
    <item>
      <title>Protecting messages with E4</title>
      <link>/getting-started/go/2-e4-integration/</link>
      <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/getting-started/go/2-e4-integration/</guid>
      <description>In previous part, we made a simple application where alice and bob could exchange messages. But now we want them to be able to communicate privately, even if eve subscribe to the MQTT topic.
To do so, we&#39;ll integrate the E4 library in our application, and create a symmetric key, and securely share it with alice and bob, so they can encrypt their messages with it. After this, only key holders could read the exchanged messages.</description>
    </item>
    
    <item>
      <title>Integration</title>
      <link>/specifications/integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/integration/</guid>
      <description>Client integration Server integration (C2)  Services Database Requirements Disaster recovery High availability Fault tolerance Logging   Key provisioning  Client integration The E4 client can be integrated in one of the following ways:
  Software library: We currently have a C and Go version of the E4 library, which developers can integrate in their applications. The E4 logic sits between the application logic and the transport layer: when transmitting a message, the code of the application logic will first call the E4 library&#39;s protect() function before calling MQTT&#39;s sending function, instead of sending the unencrypted message directly.</description>
    </item>
    
    <item>
      <title>Setting up E4 clients</title>
      <link>/getting-started/go/3-setting-up-clients/</link>
      <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/getting-started/go/3-setting-up-clients/</guid>
      <description>Previously, we&#39;ve updated our application to integrate the E4 library, and protect and unprotect the exchanged messages. But we could not communicate yet, since the clients didn&#39;t hold any keys necessary to encrypt or decrypt the messages. We&#39;ll fix this now.
E4 clients can receive commands, meant to update their internal state, like the list of topic keys they can uses. So to fix our issue, we&#39;ll need to:
 generate a topic key for /e4demo/messages topic send this key to each clients, on their respective E4 receiving topics  Once clients have received the key, alice will be able to protect message she send, and unprotect messages from bob.</description>
    </item>
    
    <item>
      <title>Client specification</title>
      <link>/specifications/client-specification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/client-specification/</guid>
      <description>Client internal state Client local API (rx)  protect_message(message, topic) unprotect(message, topic)   Client remote API (rx)  RemoveTopic(topichash) ResetTopics() SetIdKey(key) SetTopicKey(topichash, key) RemovePubKey(id) [PK mode] ResetPubKeys() [PK mode] SetPubKey(id, pubkey) [PK mode] SetC2Key(pubkey) [PK mode]   Key transition logic  E4 clients are for example sensors devices, vehicles, mobile phones, backend servers or any type of device that participates in the communication.
In order to receive commands from the C2, a client&#39;s MQTT service must subscribe to the topic E4/&amp;lt;id&amp;gt;, with their own id in hexadecimal (lower-case).</description>
    </item>
    
    <item>
      <title>Going further</title>
      <link>/getting-started/go/4-going-further/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/getting-started/go/4-going-further/</guid>
      <description>At this point, we have a working solution to secure communication over a shared topic, where all topic&#39;s members can send and receive encrypted messages from every other members. But E4 also allow us to explore another scenario, where we can choose who a client is authorized to receive messages from. Let&#39;s imagine eve have been given the topic key so she can send and receive messages, but she&#39;s not allowed to send messages to alice and bob.</description>
    </item>
    
    <item>
      <title>C2 specification</title>
      <link>/specifications/c2-specification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/c2-specification/</guid>
      <description>C2 internal state C2 API  new_client(id, key) [local] remove_client(id) [local] new_topic_client(id, topic) [remote] remove_topic_client(id, topic) [remote] reset_client(id) [remote] new_topic(topic) [local] remove_topic(topic) [local] new_client_key(id) [local &amp;amp; remote, SK mode] reset_client_pubkeys(id) [remote, PK mode] send_client_pubkey(iddst, idsrc) [remote, PK mode] remove_client_pubkey(iddst, idsrc) [remote, PK mode] new_c2_key() [local &amp;amp; remote, PK mode]   C2 human interface  C2 (command-and-control) is the host that manages clients&amp;rsquo; keys remotely, by sending commands to clients over MQTT.</description>
    </item>
    
    <item>
      <title>Message encoding</title>
      <link>/specifications/messages-encoding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/messages-encoding/</guid>
      <description>Client and C2 messages encoding [SK mode] Client messages encoding [PK mode] C2 messages encoding [PK mode]  This section describes the format of protected messages and how they are (de)serialized:
  Messages exchanged between E4 clients under an arbitrary topic for which keys have been provisioned.
  Messages sent from C2 to clients. These messages contain a command whose format is specified below.
  The QoS of messages sent by clients is defined by the application, and does not affect E4&#39;s encryption/decryption operations, which are stateless.</description>
    </item>
    
    <item>
      <title>Cryptography primitives</title>
      <link>/specifications/cryptography-primitives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/cryptography-primitives/</guid>
      <description>Authenticated encryption Hashing Password-based key derivation Signature [PK mode] Key agreement [PK mode]  This section lists the default cryptography algorithms used in E4. We can also integrate other algorithms based on customers&amp;rsquo; preferences, as well as custom proprietary algorithms, both as a replacement or as an additional encryption layer.
Authenticated encryption E4 uses the AES-SIV authenticated encryption mode as specified in RFC 5297, with a same 256-bit key for the internal MAC and CTR instance, with by default no nonce.</description>
    </item>
    
    <item>
      <title>Protocol variants</title>
      <link>/specifications/protocol-variants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/protocol-variants/</guid>
      <description>FIPS mode Post-quantum mode  FIPS mode E4&#39;s FIPS allows the application that uses it to obtain a FIPS 140-2 validation (CMVP). For this, only FIPS-compliant algorithms must be used.
In its default version, E4 uses SHA-3 (FIPS-compliant), however it uses AES in SIV mode, a mode that is not FIPS-compliant. E4&#39;s FIPS mode therefore replaces AES-SIV with AES-GCM.
In the public-key version of E4,
 Ed25519 is replaced with FIPS-compliant probabilistic ECDSA.</description>
    </item>
    
    <item>
      <title>Additional components</title>
      <link>/specifications/additional-components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specifications/additional-components/</guid>
      <description>Automation engine Monitoring &amp;amp; analytics Keygen  This section briefly describes additional server components, implementing other features than the core C2 key management logic:
Automation engine The automation engine (AE) is a separate application which will connect to the C2 in order to subscribe to an event stream. It&#39;s role is to rotates topic or clients keys according to a period defined by the user, or according to events occurring on the C2 (such as devices joining/leaving a topic).</description>
    </item>
    
  </channel>
</rss>